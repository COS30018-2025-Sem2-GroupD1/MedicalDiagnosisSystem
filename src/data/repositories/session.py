# data/repositories/chat.py
"""
Chat session management operations for MongoDB.

@TODO Review and revise.
"""

import uuid
from datetime import datetime, timedelta, timezone
from typing import Any

from pymongo import DESCENDING
from pymongo.errors import (ConnectionFailure, DuplicateKeyError,
                            OperationFailure, PyMongoError)

from src.data.connection import ActionFailed, get_collection
from src.utils.logger import logger

CHAT_SESSIONS_COLLECTION = "chat_sessions"
CHAT_MESSAGES_COLLECTION = "chat_messages"

def create_session(
	user_id: str,
	title: str,
	*,
	collection_name: str = CHAT_SESSIONS_COLLECTION
) -> str:
	"""
		Creates a new chat session.

		@TODO Revise if the session id should be passed in or generated by the database.
	"""
	collection = get_collection(collection_name)
	now = datetime.now(timezone.utc)
	session_data: dict[str, Any] = {
		"_id": str(uuid.uuid4()),
		"user_id": user_id,
		"title": title,
		"created_at": now,
		"updated_at": now
	}
	try:
		result = collection.insert_one(session_data)
		return str(result.inserted_id)
	except Exception as e:
		logger().error(f"Failed to create chat session with data {session_data}: {e}")
		raise

def get_user_sessions(
	user_id: str,
	/,
	limit: int = 20,
	*,
	collection_name: str = CHAT_SESSIONS_COLLECTION
) -> list[dict[str, Any]]:
	"""Retrieves chat sessions for a specific user."""
	collection = get_collection(collection_name)
	cursor = collection.find(
		{"user_id": user_id}
	).sort(
		"updated_at", DESCENDING
	).limit(limit)
	return list(cursor)

def ensure_session(
	*,
	session_id: str,
	patient_id: str,
	doctor_id: str,
	title: str,
	last_activity: datetime | None = None,
	collection_name: str = CHAT_SESSIONS_COLLECTION
) -> None:
	collection = get_collection(collection_name)
	now = datetime.now(timezone.utc)
	collection.update_one(
		{"session_id": session_id},
		{"$set": {
			"session_id": session_id,
			"patient_id": patient_id,
			"doctor_id": doctor_id,
			"title": title,
			"last_activity": (last_activity or now),
			"updated_at": now
		}, "$setOnInsert": {"created_at": now}},
		upsert=True
	)

def list_patient_sessions(
	patient_id: str,
	/,
	*,
	collection_name: str = CHAT_SESSIONS_COLLECTION
) -> list[dict[str, Any]]:
	collection = get_collection(collection_name)
	sessions = list(collection.find({"patient_id": patient_id}).sort("last_activity", DESCENDING))
	# Convert ObjectId to string for JSON serialization
	for session in sessions:
		if "_id" in session:
			session["_id"] = str(session["_id"])
	return sessions

def add_message(
	session_id: str,
	/,
	message_data: dict[str, Any],
	*,
	collection_name: str = CHAT_SESSIONS_COLLECTION
) -> str:
	"""Adds a message to a chat session, raising an error if the session is not found."""
	collection = get_collection(collection_name)
	now = datetime.now(timezone.utc)
	message_data["timestamp"] = now

	result = collection.update_one(
		{"_id": session_id},
		{
			"$push": {"messages": message_data},
			"$set": {"updated_at": now}
		}
	)

	if result.modified_count == 0:
		raise ValueError(f"Chat session not found or not modified: {session_id}")

	return session_id

def get_session(
	session_id: str,
	/, *,
	collection_name: str = CHAT_SESSIONS_COLLECTION
) -> dict[str, Any] | None:
	"""Retrieves a single chat session by its ID."""
	collection = get_collection(collection_name)
	return collection.find_one({"_id": session_id})

def get_session_messages(
	session_id: str,
	/,
	limit: int | None = None,
	*,
	collection_name: str = CHAT_SESSIONS_COLLECTION
) -> list[dict[str, Any]]:
	"""Get messages from a specific chat session"""
	collection = get_collection(collection_name)
	pipeline = [
		{"$match": {"_id": session_id}},
		{"$unwind": "$messages"},
		{"$sort": {"messages.timestamp": -1}}
	]
	if limit:
		pipeline.append({"$limit": limit})
	return [doc["messages"] for doc in collection.aggregate(pipeline)]

def update_session_title(
	session_id: str,
	/,
	title: str,
	*,
	collection_name: str = CHAT_SESSIONS_COLLECTION
) -> bool:
	"""Updates the title of a chat session."""
	collection = get_collection(collection_name)
	result = collection.update_one(
		{"_id": session_id},
		{
			"$set": {
				"title": title,
				"updated_at": datetime.now(timezone.utc)
			}
		}
	)
	return result.modified_count > 0

def delete_session(
	session_id: str,
	/, *,
	collection_name: str = CHAT_SESSIONS_COLLECTION
) -> bool:
	"""Deletes a chat session."""
	collection = get_collection(collection_name)
	result = collection.delete_one({"_id": session_id})
	return result.deleted_count > 0

def delete_session_messages(
	session_id: str,
	/,
	*,
	collection_name: str = CHAT_MESSAGES_COLLECTION
) -> int:
	"""Delete all messages for a session from MongoDB"""
	collection = get_collection(collection_name)
	result = collection.delete_many({"session_id": session_id})
	return result.deleted_count

def delete_old_sessions(
	days: int = 30,
	*,
	collection_name: str = CHAT_SESSIONS_COLLECTION
) -> int:
	"""Delete chat sessions older than specified days"""
	collection = get_collection(collection_name)
	cutoff = datetime.now(timezone.utc) - timedelta(days=days)
	result = collection.delete_many({
		"updated_at": {"$lt": cutoff}
	})
	if result.deleted_count > 0:
		logger().info(f"Deleted {result.deleted_count} old sessions (>{days} days)")
	return result.deleted_count
