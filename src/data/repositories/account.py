# data/repositories/account.py
"""
User account management operations for MongoDB.
Each account represents a doctor.

## Fields
	_id: index
	name: the name attached to the account
	role:
	specialty:
	medical_roles:
	created_at: the timestamp when the account was created
	updated_at: the timestamp when the account data was last modified
"""

import re
from datetime import datetime, timezone
from typing import Any

from pandas import DataFrame
from pymongo import ASCENDING
from pymongo.errors import (ConnectionFailure, DuplicateKeyError,
                            OperationFailure, PyMongoError)

from src.data.connection import (ActionFailed, EntryNotFound,
                                 create_collection, get_collection)
from src.utils.logger import logger

ACCOUNTS_COLLECTION = "accounts"

VALID_ROLES = [
	"Doctor",
	"Healthcare Prof",
	"Nurse",
	"Caregiver",
	"Physicion",
	"Medical Student",
	"Other"
]

def create():
	#get_collection(ACCOUNTS_COLLECTION).drop()
	create_collection(
		ACCOUNTS_COLLECTION,
		"schemas/account_validator.json"
	)

def get_account_frame(
	*,
	collection_name: str = ACCOUNTS_COLLECTION
) -> DataFrame:
	"""Get accounts as a pandas DataFrame"""
	return DataFrame(get_collection(collection_name).find())

def create_account(
	name: str,
	role: str,
	specialty: str | None = None,
	*,
	collection_name: str = ACCOUNTS_COLLECTION
) -> str:
	"""
		Creates a new user account.

		@TODO Revise if the user id should be passed in or generated by the database.
	"""
	collection = get_collection(collection_name)
	now = datetime.now(timezone.utc)
	user_data: dict[str, Any] = {
		"name": name,
		"role" : role,
		"specialty": specialty or "",
		"created_at": now,
		"updated_at": now
	}

	try:
		result = collection.insert_one(user_data)
		logger().info(f"Created new account: {result.inserted_id}")
		return str(result.inserted_id)
	except DuplicateKeyError as e:
		logger().error(f"Failed to create account due to duplicate key: {e}")
		raise

def update_account(
	user_id: str,
	/,
	updates: dict[str, Any],
	*,
	collection_name: str = ACCOUNTS_COLLECTION
) -> bool:
	"""Updates an existing user account."""
	collection = get_collection(collection_name)
	if updates.get("created_at", None):
		logger().warning("Attempting to modify the 'created_at' attribute of an account. Do not do this.")
		updates.pop("created_at")
	updates["updated_at"] = datetime.now(timezone.utc)
	result = collection.update_one(
		{"_id": user_id},
		{"$set": updates}
	)
	return result.modified_count > 0

def get_account(
	user_id: str,
	/, *,
	collection_name: str = ACCOUNTS_COLLECTION
) -> dict[str, Any] | None:
	"""Retrieves an account by ID and updates their last_seen timestamp."""
	collection = get_collection(collection_name)
	now = datetime.now(timezone.utc)
	return collection.find_one_and_update(
		{"_id": user_id},
		{
			"$set": {
				"last_seen": now
			}
		},
		return_document=True
	)

def get_account_by_name(name: str) -> dict[str, Any] | None:
	"""Get account by name from accounts collection"""
	logger().info("Trying to retrieve account: " + name)
	collection = get_collection(ACCOUNTS_COLLECTION)
	account = collection.find_one({"name": name})
	# HACK This somehow stops some unusual bug with creating a new account.
	if account:
		account["_id"] = str(account.get("_id")) if account.get("_id") else None
	return account

def search_accounts(query: str, limit: int = 10) -> list[dict[str, Any]]:
	"""Search accounts by name (case-insensitive contains) from accounts collection"""
	collection = get_collection(ACCOUNTS_COLLECTION)
	if not query:
		return []

	logger().info(f"Searching accounts with query: '{query}', limit: {limit}")

	# Build a regex for name search
	pattern = re.compile(re.escape(query), re.IGNORECASE)

	try:
		cursor = collection.find({
			"name": {"$regex": pattern},
			"role": {
				"$in": [
					"Doctor",
					"Healthcare Prof",
					"General Practitioner",
					"Cardiologist",
					"Pediatrician",
					"Neurologist",
					"Dermatologist"
				]
			}
		}).sort("name", ASCENDING).limit(limit)
		results = []
		for d in cursor:
			d["_id"] = str(d.get("_id")) if d.get("_id") else None
			results.append(d)
		logger().info(f"Found {len(results)} accounts matching query")
		return results
	except Exception as e:
		logger().error(f"Error in search_account: {e}")
		return []


def get_all_accounts(limit: int = 50) -> list[dict[str, Any]]:
	"""Get all doctors with optional limit from accounts collection"""
	collection = get_collection(ACCOUNTS_COLLECTION)
	try:
		cursor = collection.find().sort("name", ASCENDING).limit(limit)
		results = []
		for d in cursor:
			d["_id"] = str(d.get("_id")) if d.get("_id") else None
			results.append(d)
		logger().info(f"Retrieved {len(results)} doctors")
		return results
	except Exception as e:
		logger().error(f"Error getting all doctors: {e}")
		return []
